<!DOCTYPE html>
<html>
<head>
    <title>Live Run Tracking</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>Live Run Tracking</h1>
    
    <div class="info-box">
        <p><strong>Segment:</strong> <span id="current-segment">0</span> / <span id="total-segments">{{ total_segments }}</span></p>
        <p style="font-weight: bold; color: #3498db">
            <strong>Distance:</strong> <span id="segment-distance">1.0</span> km
        </p>
        <p><strong>Elevation Gain:</strong> <span id="elevation-gain">--</span> m | <strong>Elevation Loss:</strong> <span id="elevation-loss">--</span> m</p>
        <p style="font-size: 32px; font-weight: bold; color: #3498db; margin-top: 15px;">
        <strong>Segment Predicted Pace:</strong> <span id="predicted-pace">--:--</span> min/km
        </p>
    </div>

    <div class="timer-display" id="total-timer">00:00:00</div>
    <p class="timer-label">Total Time</p>

    <div class="segment-timer" id="segment-timer">00:00</div>
    <p class="timer-label">Current Segment Time</p>

    <button class="button-success" id="start-button" onclick="startRun()">START RUN</button>
    <button class="button-warning" id="pause-button" onclick="togglePause()" disabled style="display: none;">PAUSE</button>
    <button class="button-primary" id="split-button" onclick="logSplit()" disabled>LOG SPLIT</button>


<div id="completion-message" style="display: none;">
    <div class="completion-box">
        <h2 style="color: #27ae60; margin-bottom: 20px;">ðŸŽ‰ Run Complete! ðŸŽ‰</h2>
        <p style="font-size: 18px; margin-bottom: 20px;">Great job! You've completed all segments.</p>
        <a href="/run_summary" class="button button-success">View Run Summary</a>
    </div>
</div>

    <div class="mt-20">
        <h3>Completed Segments</h3>
        <table class="data">
            <thead>
                <tr>
                    <th>Segment</th>
                    <th>Actual Time</th>
                    <th>Predicted Time</th>
                    <th>Difference</th>
                </tr>
            </thead>
            <tbody id="splits-body">
            </tbody>
        </table>
    </div>

    <script>
        let timerInterval = null;
        let startTime = null;
        let segmentStartTime = null;
        let currentSegment = 0;
        let isPaused = false;
        let pauseStartTime = null;
        let totalPausedTime = 0;
        let segmentPausedTime = 0;
        const totalSegments = {{ total_segments | int }};
        const segmentDistances = {{ segment_distances | tojson | safe }};
        const predictedPaces = {{ predicted_paces | tojson | safe }};
        const elevationGains = {{ elevation_gains | tojson | safe }};
        const elevationLosses = {{ elevation_losses | tojson | safe }};

        function hapticFeedback(pattern = 'short') {
            if (!('vibrate' in navigator)) return; // check if the device supports vibration
            
            const patterns = {
                'short': 100, // quick tap
                'medium': 200, // normal press
                'long': 300, // strong press
                'double': [100, 100, 100], // two quick pulses
                'success': [50, 50, 50] // three quick pulses for success
            };
    
            navigator.vibrate(patterns[pattern] || 50);
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatPace(minutes) {
            const min = Math.floor(minutes);
            const sec = Math.floor((minutes - min) * 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }

        function updateTimers() {
            if (isPaused) {
                return;  // timer frozen while paused
            }
            
            const now = Date.now() / 1000;
            const totalElapsed = now - startTime - totalPausedTime;
            document.getElementById('total-timer').textContent = formatTime(totalElapsed);

            const segmentElapsed = now - segmentStartTime - segmentPausedTime;
            document.getElementById('segment-timer').textContent = formatTime(segmentElapsed);
        }

        function startRun() {
            hapticFeedback('long');
            fetch('/start_run', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'started') {
                        startTime = Date.now() / 1000;
                        segmentStartTime = startTime;
                        document.getElementById('start-button').disabled = true;
                        document.getElementById('split-button').disabled = false;

                        console.log('[START] startTime:', startTime);
                    console.log('[START] segmentStartTime:', segmentStartTime);
                        
                        totalPausedTime = 0;
                        segmentPausedTime = 0;
                        document.getElementById('pause-button').disabled = false;
                        document.getElementById('pause-button').style.display = 'inline-block';
                        timerInterval = setInterval(updateTimers, 100);
                        updateSegmentInfo();
                    }
                });
        }

        function logSplit() {
            hapticFeedback('double');
            
            const now = Date.now() / 1000;
            const frontendSegmentTime = now - segmentStartTime - segmentPausedTime;
            console.log('[SPLIT - BEFORE] Frontend segment time:', frontendSegmentTime);
            console.log('[SPLIT - BEFORE] now:', now);
            console.log('[SPLIT - BEFORE] segmentStartTime:', segmentStartTime);
            console.log('[SPLIT - BEFORE] segmentPausedTime:', segmentPausedTime);
            
            fetch('/log_split', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('[SPLIT - RESPONSE] Backend data:', data);
                    console.log('[SPLIT - RESPONSE] Backend segment time:', data.actual_time_sec);
                    console.log('[SPLIT - RESPONSE] Difference:', Math.abs(frontendSegmentTime - data.actual_time_sec));
                    
                    if (data.segment) {
                        const tbody = document.getElementById('splits-body');
                        const row = tbody.insertRow();
                        
                        const actualTime = formatTime(data.actual_time_sec); // format actual segment TIME
                        
                        
                        const segmentDist = segmentDistances[data.segment - 1]; // calculate predicted segment TIME
                        let predictedTimeMin;
                        
                        if (data.segment === totalSegments && segmentDist < 0.85) {
                            predictedTimeMin = data.predicted_pace_min * segmentDist;
                        } else {
                            predictedTimeMin = data.predicted_pace_min * 1.0;  // assume exactly 1km
                        }
                        
                        const predictedTimeSec = predictedTimeMin * 60;  // convert to seconds
                        const predictedTime = formatTime(predictedTimeSec);
                        
                        
                        const timeDiffSec = data.actual_time_sec - predictedTimeSec; // calculate TIME difference (actual - predicted)
                        const diffFormatted = `${timeDiffSec < 0 ? '-' : '+'}${Math.abs(Math.round(timeDiffSec))}s`;
                        const diffClass = timeDiffSec < 0 ? 'faster' : 'slower';

                        row.innerHTML = `
                            <td>${data.segment}</td>
                            <td>${actualTime}</td>
                            <td>${predictedTime}</td>
                            <td class="${diffClass}">${diffFormatted}</td>
                        `;

                        
                        const oldSegmentStartTime = segmentStartTime; // reset segment timer
                        segmentStartTime = Date.now() / 1000;
                        segmentPausedTime = 0;
                        currentSegment = data.segment;
                        
                        console.log('[SPLIT - RESET] Old segmentStartTime:', oldSegmentStartTime);
                        console.log('[SPLIT - RESET] New segmentStartTime:', segmentStartTime);
                        console.log('[SPLIT - RESET] Reset segmentPausedTime to 0');
                        
                        updateSegmentInfo();

                        if (data.run_completed) {
                            clearInterval(timerInterval);
                            document.getElementById('split-button').disabled = true;
                            document.getElementById('completion-message').style.display = 'block';
                            document.getElementById('completion-message').scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'center' 
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('[SPLIT - ERROR]', error);
                    alert('Error logging split: ' + error.message);
                });
        }

        function togglePause() {
            hapticFeedback('long');

            if (isPaused) {
                console.log('[PAUSE] Resuming...'); // resume
                fetch('/resume_run', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'resumed') {

                            const pauseDuration = data.pause_duration;

                            console.log('[PAUSE] Pause duration:', pauseDuration);
                            console.log('[PAUSE] Old totalPausedTime:', totalPausedTime);
                            console.log('[PAUSE] Old segmentPausedTime:', segmentPausedTime);

                            totalPausedTime += pauseDuration;
                            segmentPausedTime += pauseDuration;  // only update total time

                            //startTime += pauseDuration;
                            //segmentStartTime += pauseDuration;

                            console.log('[PAUSE] New totalPausedTime:', totalPausedTime);
                            console.log('[PAUSE] New segmentPausedTime:', segmentPausedTime);
                            
                            isPaused = false;
                            pauseStartTime = null;
                            document.getElementById('pause-button').textContent = 'PAUSE';
                            document.getElementById('pause-button').className = 'button-warning';
                            document.getElementById('split-button').disabled = false;
                            timerInterval = setInterval(updateTimers, 100);
                        }
                    });
            } else {
                pauseStartTime = Date.now() / 1000;
                console.log('[PAUSE] Pausing...'); // pause
                fetch('/pause_run', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'paused') {
                            isPaused = true;
                            document.getElementById('pause-button').textContent = 'RESUME';
                            document.getElementById('pause-button').className = 'button-success';
                            document.getElementById('split-button').disabled = true;
                            clearInterval(timerInterval);
                        }
                    });
            }
        }

        function updateSegmentInfo() {
            document.getElementById('current-segment').textContent = currentSegment;
            if (currentSegment < predictedPaces.length) {
                let distance = segmentDistances[currentSegment]; // update distance 1 if close, otherwise show actual for partial segments
                if (distance >= 0.89) {
                    distance = 1.0;
                } else distance = segmentDistances[currentSegment];
                document.getElementById('segment-distance').textContent = distance.toFixed(2);
                document.getElementById('predicted-pace').textContent = formatPace(predictedPaces[currentSegment]);
                document.getElementById('elevation-gain').textContent = elevationGains[currentSegment].toFixed(1);
                document.getElementById('elevation-loss').textContent = elevationLosses[currentSegment].toFixed(1);
            }
        }
    </script>
</body>
</html>