<!DOCTYPE html>
<html>
<head>
    <title>Live Run Tracking</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>Live Run Tracking</h1>
    
    <div class="info-box">
        <p><strong>Segment:</strong> <span id="current-segment">0</span> / <span id="total-segments">{{ total_segments }}</span></p>
        <p><strong>Elevation Gain:</strong> <span id="elevation-gain">--</span> m | <strong>Elevation Loss:</strong> <span id="elevation-loss">--</span> m</p>
        <p style="font-size: 32px; font-weight: bold; color: #3498db; margin-top: 15px;">
        <strong>Segment Predicted Pace:</strong> <span id="predicted-pace">--:--</span> min/km
        </p>
    </div>

    <div class="timer-display" id="total-timer">00:00:00</div>
    <p class="timer-label">Total Time</p>

    <div class="segment-timer" id="segment-timer">00:00</div>
    <p class="timer-label">Current Segment Time</p>

    <button class="button-success" id="start-button" onclick="startRun()">START RUN</button>
    <button class="button-warning" id="pause-button" onclick="togglePause()" disabled style="display: none;">PAUSE</button>
    <button class="button-primary" id="split-button" onclick="logSplit()" disabled>LOG SPLIT</button>

    <!-- Completion Message (hidden by default) -->
<div id="completion-message" style="display: none;">
    <div class="completion-box">
        <h2 style="color: #27ae60; margin-bottom: 20px;">ðŸŽ‰ Run Complete! ðŸŽ‰</h2>
        <p style="font-size: 18px; margin-bottom: 20px;">Great job! You've completed all segments.</p>
        <a href="/run_summary" class="button button-success">View Run Summary</a>
    </div>
</div>

    <div class="mt-20">
        <h3>Completed Segments</h3>
        <table class="data">
            <thead>
                <tr>
                    <th>Segment</th>
                    <th>Actual Time</th>
                    <th>Predicted Time</th>
                    <th>Difference</th>
                </tr>
            </thead>
            <tbody id="splits-body">
                <!-- Splits will be added here -->
            </tbody>
        </table>
    </div>

    <script>
        // Your existing JavaScript stays the same
        let timerInterval = null;
        let startTime = null;
        let segmentStartTime = null;
        let currentSegment = 0;
        let isPaused = false;
        let totalPausedTime = 0;
        let segmentPausedTime = 0;
        const totalSegments = {{ total_segments | int }};
        const predictedPaces = {{ predicted_paces | tojson | safe }};
        const elevationGains = {{ elevation_gains | tojson | safe }};
        const elevationLosses = {{ elevation_losses | tojson | safe }};

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatPace(minutes) {
            const min = Math.floor(minutes);
            const sec = Math.floor((minutes - min) * 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }

        function updateTimers() {
            if (isPaused) {
                return;  // Timer frozen while paused
            }
            
            const now = Date.now() / 1000;
            const totalElapsed = now - startTime;
            document.getElementById('total-timer').textContent = formatTime(totalElapsed);
            
            // Segment timer just shows time since segment started (no pause adjustment needed in frontend)
            const segmentElapsed = now - segmentStartTime;
            document.getElementById('segment-timer').textContent = formatTime(segmentElapsed);
        }

        function startRun() {
            fetch('/start_run', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'started') {
                        startTime = Date.now() / 1000;
                        segmentStartTime = startTime;
                        document.getElementById('start-button').disabled = true;
                        document.getElementById('split-button').disabled = false;
                        
                        totalPausedTime = 0;
                        segmentPausedTime = 0;
                        document.getElementById('pause-button').disabled = false;
                        document.getElementById('pause-button').style.display = 'inline-block';
                        timerInterval = setInterval(updateTimers, 100);
                        updateSegmentInfo();
                    }
                });
        }

        function logSplit() {
            fetch('/log_split', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.segment) {
                        const tbody = document.getElementById('splits-body');
                        const row = tbody.insertRow();
                        const actualPace = formatPace(data.actual_pace_min);
                        const predictedPace = formatPace(data.predicted_pace_min);
                        const diffSecs = Math.round(data.difference_sec);
                        const diffFormatted = `${data.faster ? '-' : '+'}${Math.abs(diffSecs)}s`;
                        const diffClass = data.faster ? 'faster' : 'slower';

                        row.innerHTML = `
                            <td>${data.segment}</td>
                            <td>${actualPace}</td>
                            <td>${predictedPace}</td>
                            <td class="${diffClass}">${diffFormatted}</td>
                        `;

                        segmentStartTime = Date.now() / 1000;
                        segmentPausedTime = 0;
                        currentSegment = data.segment;
                        updateSegmentInfo();

                        if (data.run_completed) {
                            clearInterval(timerInterval);
                            document.getElementById('split-button').disabled = true;
                            
                            // Show completion message instead of alert
                            document.getElementById('completion-message').style.display = 'block';
                            
                            // Scroll to completion message
                            document.getElementById('completion-message').scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'center' 
                            });
                        }
                    }
                });
        }

        function togglePause() {
            if (isPaused) {
                // Resume
                fetch('/resume_run', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'resumed') {

                            const pauseDuration = data.pause_duration;

                            totalPausedTime += pauseDuration;
                            totalPausedTime += data.pause_duration;  // Only update total

                            startTime += pauseDuration;
                            segmentStartTime += pauseDuration;
                            
                            isPaused = false;
                            document.getElementById('pause-button').textContent = 'PAUSE';
                            document.getElementById('pause-button').className = 'button-warning';
                            document.getElementById('split-button').disabled = false;
                            timerInterval = setInterval(updateTimers, 100);
                        }
                    });
            } else {
                // Pause
                fetch('/pause_run', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'paused') {
                            isPaused = true;
                            document.getElementById('pause-button').textContent = 'RESUME';
                            document.getElementById('pause-button').className = 'button-success';
                            document.getElementById('split-button').disabled = true;
                            clearInterval(timerInterval);
                        }
                    });
            }
        }

        function updateSegmentInfo() {
            document.getElementById('current-segment').textContent = currentSegment;
            if (currentSegment < predictedPaces.length) {
                document.getElementById('predicted-pace').textContent = formatPace(predictedPaces[currentSegment]);
                document.getElementById('elevation-gain').textContent = elevationGains[currentSegment].toFixed(1);
                document.getElementById('elevation-loss').textContent = elevationLosses[currentSegment].toFixed(1);
            }
        }
    </script>
</body>
</html>